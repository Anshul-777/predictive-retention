
import joblib
import pandas as pd
import numpy as np
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field
from typing import Literal, List
from fastapi.middleware.cors import CORSMiddleware

# 3. Load the saved model, scaler, and encoder objects into global variables
# Ensure these files are in the same directory as main.py or provide the correct path
loaded_lgbm_model = joblib.load('best_lgbm_model.joblib')
loaded_scaler = joblib.load('scaler.joblib')
loaded_encoder = joblib.load('encoder.joblib')

# Numerical features that were scaled
numerical_features_model_columns = ['SeniorCitizen', 'tenure', 'MonthlyCharges', 'TotalCharges', 'Num_Addon_Services', 'Has_Internet_No_Security']

# Categorical features that were one-hot encoded
categorical_features_for_encoder = ['gender', 'Partner', 'Dependents', 'PhoneService', 'MultipleLines', 'InternetService', 'Contract', 'PaperlessBilling', 'PaymentMethod']

# Get the feature names generated by the encoder
encoded_feature_names = loaded_encoder.get_feature_names_out(categorical_features_for_encoder)

# Combine all feature names in the correct order for the model input
MODEL_FEATURES = numerical_features_model_columns + list(encoded_feature_names)


print("Model, scaler, and encoder loaded successfully.")
print(f"Expected model features: {MODEL_FEATURES[:5]}... ({len(MODEL_FEATURES)} total)")

# 4. Define a Pydantic BaseModel named CustomerData
class CustomerData(BaseModel):
    gender: Literal['Male', 'Female']
    SeniorCitizen: Literal[0, 1]
    Partner: Literal['Yes', 'No']
    Dependents: Literal['Yes', 'No']
    tenure: int = Field(..., ge=0, le=72)
    PhoneService: Literal['Yes', 'No']
    MultipleLines: Literal['Yes', 'No', 'No phone service']
    InternetService: Literal['DSL', 'Fiber optic', 'No']
    OnlineSecurity: Literal['Yes', 'No', 'No internet service']
    OnlineBackup: Literal['Yes', 'No', 'No internet service']
    DeviceProtection: Literal['Yes', 'No', 'No internet service']
    TechSupport: Literal['Yes', 'No', 'No internet service']
    StreamingTV: Literal['Yes', 'No', 'No internet service']
    StreamingMovies: Literal['Yes', 'No', 'No internet service']
    Contract: Literal['Month-to-month', 'One year', 'Two year']
    PaperlessBilling: Literal['Yes', 'No']
    PaymentMethod: Literal['Electronic check', 'Mailed check', 'Bank transfer (automatic)', 'Credit card (automatic)']
    MonthlyCharges: float = Field(..., ge=0)
    TotalCharges: float = Field(..., ge=0)

# 5. Define a Pydantic BaseModel named PredictionResponse
class PredictionResponse(BaseModel):
    predicted_churn_status: str
    probability_of_churn: float
    risk_level: Literal['Low', 'Medium', 'High']
    recommendations: List[str]

# 6. Create a helper function, e.g., preprocess_input(customer_data: CustomerData)
def preprocess_input(customer_data: CustomerData) -> pd.DataFrame:
    # Convert the CustomerData into a pandas DataFrame
    user_df = pd.DataFrame([customer_data.model_dump()])

    # Replicate the feature engineering steps
    addon_cols_map = {'Yes': 1, 'No': 0, 'No internet service': 0}
    addon_cols = ['OnlineSecurity', 'OnlineBackup', 'DeviceProtection', 'TechSupport', 'StreamingTV', 'StreamingMovies']

    for col in addon_cols:
        user_df.loc[:, col] = user_df[col].map(addon_cols_map)

    user_df.loc[:, 'Num_Addon_Services'] = user_df[addon_cols].sum(axis=1)

    user_df.loc[:, 'Has_Internet_No_Security'] = (
        (user_df['InternetService'] != 'No') &
        (user_df['OnlineSecurity'] == 0) &
        (user_df['TechSupport'] == 0)
    ).astype(int)

    # Identify categorical and numerical features for processing
    # Note: 'SeniorCitizen' is treated as numerical for scaling purposes.

    # Use the loaded OneHotEncoder to preprocess categorical features.
    # Ensure the order of categorical features for encoding matches the training.
    encoded_user_features = loaded_encoder.transform(user_df[categorical_features_for_encoder])
    encoded_user_df = pd.DataFrame(encoded_user_features, columns=loaded_encoder.get_feature_names_out(categorical_features_for_encoder))

    # Use the loaded StandardScaler to preprocess numerical features.
    scaled_user_features = loaded_scaler.transform(user_df[numerical_features_model_columns])
    scaled_user_df = pd.DataFrame(scaled_user_features, columns=numerical_features_model_columns)

    # Concatenate the processed features and ensure column order matches MODEL_FEATURES
    preprocessed_data_df = pd.concat([scaled_user_df, encoded_user_df], axis=1)
    
    # Ensure column order matches the training data by reindexing
    preprocessed_data_df = preprocessed_data_df.reindex(columns=MODEL_FEATURES, fill_value=0)

    return preprocessed_data_df

# 7. Instantiate the FastAPI application
app = FastAPI()

# 8. Configure CORSMiddleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173", "http://localhost:3000"], # Adjust for your frontend URL(s)
    allow_credentials=True,
    allow_methods=["GET", "POST"],
    allow_headers=["*"]
)

# 9. Implement a POST endpoint '/predict'
@app.post("/predict", response_model=PredictionResponse)
async def predict_churn(customer_data: CustomerData):
    try:
        # Preprocess the input data
        processed_input = preprocess_input(customer_data)

        # Make a prediction
        churn_probability = loaded_lgbm_model.predict_proba(processed_input)[:, 1][0]
        predicted_churn = (churn_probability >= 0.5).astype(int) # Default threshold of 0.5
        
        # Determine risk level and recommendations
        if predicted_churn == 1:
            predicted_churn_status = "Churn (Likely to leave)"
            risk_level = "High"
            recommendations = [
                "Offer a special retention discount or package.",
                "Contact customer to understand dissatisfaction points.",
                "Highlight benefits of current services."
            ]
            if customer_data.Contract == 'Month-to-month':
                recommendations.append("Propose switching to a longer-term contract with incentives.")
            if customer_data.MonthlyCharges > 100: # Example threshold for high charges
                 recommendations.append("Review pricing and competitive offers.")
            if customer_data.TechSupport == 'No':
                 recommendations.append("Offer free premium tech support for a limited period.")
        else:
            predicted_churn_status = "No Churn (Likely to stay)"
            risk_level = "Low"
            recommendations = [
                "Continue to monitor customer satisfaction.",
                "Consider upselling relevant add-on services.",
                "Reward loyalty with occasional perks."
            ]
            if customer_data.Contract == 'Month-to-month':
                recommendations.append("Encourage migration to longer-term contracts to secure loyalty.")

        return PredictionResponse(
            predicted_churn_status=predicted_churn_status,
            probability_of_churn=churn_probability,
            risk_level=risk_level,
            recommendations=recommendations
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
